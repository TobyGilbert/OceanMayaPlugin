/*! \mainpage  Report
  The following image is rendered with my plugin and SolidAngle's Arnold renderer.
  \image html arnold2.png
  \section sec The Algorithm
  In order to give a realistic simulation of an ocean surface a set of equation first put forward by
  Jerry Tessendorf can be used.  His equations output a heightfield in the frequency domain which
  can be converted to the time domain using the inverse fast fourier transform equation.  To generate
  this heightfiled the following equation can be used:
  \image html tessendorf01.jpg
  Where  h(x,t) represents the height at horizontal position x and time t.  In order to evaluate this sum
  we an use inverse FFT.
  The discreate range for vector k can be seen below, where L represents the size of the grid we simulate FFT
  and N is the user changeable resolution of the grid of points.
  \image html tessendorf03.jpg
  In order to create a set of amplitudes and phases we need to use the Phillips spectrum.  This spectrum has
  been put forward by Oceanographic research.  Where w represents the wind vector. The |k.w|^2 term represents
  filters out waves moving perpendicular to the wind direction.  In my demo I have also filtered out waves
  moving in the opposite direction to the wind by reducing the Phillips spectrum to 0 where |k.w| < 0.
  \image html tessendorf04.jpg
  Another improvement is to eliminate waves smaller than length l << L.  You can do this with the following equation:
  \image html tessendorf05.jpg
  Once we have our spectrum we are then able to create a height field in the frequency domain at time 0.
  \image html tessendorf06.jpg
  Zr and Zi represent two random numbers generated by a gaussian random number generator with mean 0 and standard
  deviation 1.  Once we have this we can generate this field at any time:
  \image html tessendorf07.jpg
  W is the wave frequency and for water waves the following relationship is true where g is the acceleration
  due to gravity.
  \image html tessendorf08.jpg
  Once we have a series of points in the frequency domain we can perform inverse FFT on them to retrieve the
  sin and cos waves we need to produce a height field we can use to displace he vertices.
  \n
  \n
  Although the waves produces are fairly realistic for a calm day, they have smooth curved peaks and troughs.
  In heavy wind wave peaks are far more sharp and troughs are elongated. To add this additional choppiness
  an x, z displacment has to be added.
  \image html tessendorf09.jpg
  D(x, t) represents a a displacement in x where x = (xx,xz).  The surface is now x + (phi)D(x,t) where phi
  is a scalar to alter choppiness.

  \section sec2 Implementation
  \subsection standAlonsSec Stand Alone
  I first implemented this algorithm using standard OpenGL and NVidia's Cuda.  Due to the parrallel nature of this problem I decided
  to usalise the GPU to perform the majority of the computation in this algorithm.
  - Create grid of points
  - Create a frequency field at time 0 using the Phillips specrum
  - Load thats buffer into a Cuda kernel for outputting frequency field at a particular time
  - Perform FFT using the cufft library and outputting a height as a float2, complex number where the real part is stored in the x and
  imagingary part in the y
  - Add choppiness uses the wind direction
  - Perform FFT to retrieve and displacement in x and z
  - Update the positions buffer with the new height and add displacement from the choppiness calculation
  - Calculate the new normals using the updated positions.
  \subsection MayaSec Maya Plugin
  \image html maya.png
  In order to make this a usable tool I decided to port the algorithm to the Maya platform.  The ocean Maya plugin is an MPxNode which
  outputs a MPnMesh every frame based on a number of input parameters.  Maya uses a dependency graph which means that it only has to
  update things when it is explicitly told to.  Plugs are used as points on the dependency graph where attributes can be connected and
  can be checked to see whether certain bits of code need to be evaluated.  For my plugin I use one plug which is linked to the
  output mesh.  All node attributes are then linked to this plug with the attributeAffects() function and this means that the mesh
  gets re-evaluated if any attributes are changed.  These attributes are, resolution, amplitude, frequency, the wind direction, the wind
  speed, and a choppiness parameter.\n
  Although the Maya plugin still ustilises the Cuda API there is a bottleneck in doing this.  Where in the stand alone simulation,
  once the geometry was loaded onto the GPU it could be updated, drawn and remain there, the Maya API requires an array of vertex data
  on the host side as a parameter to the MPnMesh create function.  This means that every time the mesh updates, every frame, an expensive
  copy has to made from the GPU to the host.  As it stands I am unsure of a way this can be improved and so this remains the case.
  \section sec3 Rendering
  \subsection RefractionSec Refraction
  To create a realistic ocean you need to mimic its reflective and refractive properties.  To simulate refraction
  you first need to render the ocean as a diffuse surface.  You first set up the sun with a position and direction,
  and then you can calcualte diffuse but finding the dot product between the suns direction vector and the normal
  of the surface.  You can then tint this surface by adding a blue base colour.  The ocean can be seen to change colour
  depeneding on its depth and to replicate this you can multiply the result by another lighter colour which can be seen
  when looking through a wave.
  \image html refraction.png
  \subsection ReflectionSec Reflection
  Now we have simulated refraction we now need reflection.  To do this I started by using an OpenGL cube map.  You first
  have to calculate a reflection vector which can be used as a texture lookup for the cube map.  Although this method is simple
  the main drawback is that you cannot render any local reflections, that is, reflections of any objects in the scene e.g. a boat.
  To achieve this without ray tracing in GLSL you have to use an additional preliminary render pass.  For this pass the scene
  has to be inverted, this can be done simply by scaling all the elements in the scene by -1.0 in the y axis.  A clipping plane
  must also be used which removes everything that would be below the waters surface to avoid strange reflections.  This is then
  rendered to a framebuffer and loaded as a texture to the shader.  To map this the the surface of the water projected texture coordinates
  have to be used these can be calculated by multipling the vertices screen space coordinates by 1.0/the screen space w componant.
  As texture coordinates are posative we then add 1 and divide by 2 and finally clamp these coordinate between 0 and 1.
  \image html reflection.png
  \subsection FresnelSec Fresnel
  Now we have both reflection and refraction we need a way to combine the two.  The Fresnel term give us a way to do this, we can use
  the value of frenel to scale the reflected colour and the inverse of fresenl to scale the refracted colour.  We can do this in GLSL
  using the mix() function.
  \subsection SunStreakSec Sun Streak
  Another property of water is the specular reflection you get strong light sources e.g. the sun.  To add this we reflect the sun direction
  around the normal and dot this with the position.  We can then change the width of the streak by taking this to a power.
  \image html sun.png
   Rendered with SolidAngle's Arnold
  \image html arnold.png
*/

#include "OceanNode.h"
#include <maya/MFnPlugin.h>

//----------------------------------------------------------------------------------------------------------------------

MStatus initializePlugin( MObject obj )
{
    MStatus   status;
    MFnPlugin plugin( obj, "", "Toby Gilbert" , "2015" );

  // register our nodes and the commands which will be called
    status = plugin.registerNode( "oceanNode", OceanNode::m_id, &OceanNode::creator, &OceanNode::initialize, MPxNode::kDependNode );
    if (!status)
    {
    status.perror("Unable to register OceanNode" );
        return status;
    }

    return status;
}

//----------------------------------------------------------------------------------------------------------------------

MStatus uninitializePlugin( MObject obj )
{
    MStatus   status;
    MFnPlugin plugin( obj );


  status = plugin.deregisterNode( OceanNode::m_id );
    if (!status)
    {
    status.perror( "unable to deregister OceanNode" );
        return status;
    }

    return status;
}
//----------------------------------------------------------------------------------------------------------------------


